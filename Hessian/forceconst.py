'''
Calculate Columbus7 MRCI energy internal coordinate Hessian
Output to DISPLACEMENT/../LISTINGS
This is a finite difference calculation from gradients,
    the Hessian matrix elements will be symmetrized by Hij = (Hij + Hji) / 2
    futher symmetrization will be performed given irreducible
Note that Columbus internal coordinate routines use weird unit:
    energy in 10^-18 J, length in A (to be continued)
Optionally, additionally collect geometry, MRCI energy, gradient, transition dipole
'''

import argparse
from pathlib import Path
from typing import List, Tuple
import numpy

args          = 0  # Command line input
listings      = 0  # Output path
intdim        = 0  # Internal coordinate dimension
displacements = [] # displacements[i][j] is the displacement along i-th internal coordinate
NAtoms        = 0  # Number of atoms

def parse_args() -> argparse.Namespace: # Command line input
    parser = argparse.ArgumentParser(__doc__)
    parser.add_argument('DISPLACEMENT_path', type=Path, help='location of DISPLACEMENT directory generated by colinp')
    parser.add_argument('NState', type=int, help='calculate for state 1 to NState')
    parser.add_argument('-i','--irreducible', type=int, nargs='+', help='number of internal coordinates per irreducible')
    parser.add_argument('-c','--collect', action='store_true', help='additionally collect geometry, MRCI energy, gradient, transition dipole')
    parser.add_argument('-s','--single' , action='store_true', help='NState-th state only')
    args = parser.parse_args()
    return args

# Calculate finite difference Hessian
def Hessian() -> None:
    hessian = numpy.empty((args.NState, intdim, intdim))
    for displacement in displacements:
        # Reference point is required
        if len(displacement) == 1:
            intgrad_ref = numpy.empty((args.NState, intdim))
            dir = Path(args.DISPLACEMENT_path/"REFPOINT")
            for istate in range(args.NState):
                with open(dir/'GRADIENTS'/('intgrd.drt1.state' + str(istate+1) + '.sp'), 'r') as f: lines = f.readlines()
                for i in range(intdim): intgrad_ref[istate, i] = float(lines[i].replace('D', 'e'))
            break
    # Read internal coordinate gradients and calculate finite difference
    intgrad1 = numpy.empty((intdim))
    intgrad2 = numpy.empty((intdim))
    for idim in range(intdim):
        # This assumes gradient to be antisymmetric
        if len(displacements[idim]) == 1:
            dir = Path(args.DISPLACEMENT_path/('CALC.c' + str(idim+1) + '.d' + str(displacements[idim][0])))
            for istate in range(args.NState):
                with open(dir/'GRADIENTS'/('intgrd.drt1.state' + str(istate+1) + '.sp'), 'r') as f: lines = f.readlines()
                for i in range(intdim): intgrad1[i] = float(lines[i].replace('D', 'e'))
                hessian[istate, idim, :] = (intgrad1 - intgrad_ref[istate, :]) / displacements[idim][0]
        elif len(displacements[idim]) == 2:
            dir1 = Path(args.DISPLACEMENT_path/('CALC.c' + str(idim+1) + '.d' + str(displacements[idim][0])))
            dir2 = Path(args.DISPLACEMENT_path/('CALC.c' + str(idim+1) + '.d' + str(displacements[idim][1])))
            for istate in range(args.NState):
                with open(dir1/'GRADIENTS'/('intgrd.drt1.state' + str(istate+1) + '.sp'), 'r') as f: lines1 = f.readlines()
                with open(dir2/'GRADIENTS'/('intgrd.drt1.state' + str(istate+1) + '.sp'), 'r') as f: lines2 = f.readlines()
                for i in range(intdim):
                    intgrad1[i] = float(lines1[i].replace('D', 'e'))
                    intgrad2[i] = float(lines2[i].replace('D', 'e'))
                hessian[istate, idim, :] = (intgrad1 - intgrad2) / (displacements[idim][0] - displacements[idim][1])
        else:
            print("There should be 1 or 2 displacements along internal coordinate", idim, sep=' ')
    # Symmetrize
    for i in range(intdim): 
        for j in range(i+1, intdim):
            hessian[:, i, j] = (hessian[:, i, j] + hessian[:, j, i]) / 2.0
            hessian[:, j, i] =  hessian[:, i, j]
    if args.irreducible != None:
        start = 0
        for NCoord in args.irreducible:
            stop = start + NCoord
            hessian[:, start:stop, :start] = 0.0
            hessian[:, start:stop, stop: ] = 0.0
            start = stop
    # Output hessian
    for istate in range(args.NState):
        # Hessian in Columbus 7 format
        with open(listings/('hessian'+str(istate+1)),'w') as f:
            for i in range(intdim):
                for j in range(0,intdim,8):
                    jstart=j; jstop=j+8
                    if jstop>intdim: jstop=intdim
                    for jj in range(jstart,jstop):
                        print('%13.6f' % hessian[istate,i,jj],end='',file=f)
                    print(file=f)
        # Diagonal elements in intcfl format
        with open(listings/('hessian_diag_'+str(istate+1)),'w') as f:
            for j in range(0,intdim,8):
                jstart=j; jstop=j+8
                if jstop>intdim: jstop=intdim
                for jj in range(jstart,jstop):
                    print('%10.2E'%hessian[istate,jj,jj],end='',file=f)
                print(file=f)

# Read directory, return (geometry, energy, gradient, dipole)
# The return data are original strings
def read_directory(direcotry: Path) -> Tuple[List, List, List, List]:
    ## geometry
    with open(direcotry/'geom', 'r') as f: geom = f.readlines()
    ## energy
    with open(direcotry/'LISTINGS'/'ciudgsm.sp','r') as f: lines=f.readlines()
    for title_line in range(len(lines)):
        if 'mr-sdci  convergence criteria satisfied' in lines[title_line]: break
    if title_line == len(lines) - 1 :
        print('Warning: mr-sdci did not converge at job ' + str(direcotry))
    else:
        energy = []
        for k in range(args.NState):
            temp = lines[title_line + 2 + k + 1].split()
            energy.append(temp[len(temp) - 5])
        ## gradient
        gradient = []
        for i in range(args.NState): gradient.append(0)
        for _ in range(len(gradient)):
            gradient[_] = []
            for i in range(args.NState): gradient[_].append(0)
        for istate in range(args.NState):
            with open(direcotry/'GRADIENTS'/('cartgrd.drt1.state' + str(istate+1) + '.sp'), 'r') as f:
                gradient[istate][istate] = f.readlines()
            for jstate in range(istate + 1, args.NState):
                with open(direcotry/'GRADIENTS'/('cartgrd.nad.drt1.state' + str(istate+1) + '.drt1.state' + str(jstate+1) + '.sp'), 'r') as f:
                    gradient[istate][jstate] = f.readlines()
        # transition dipole
        dipole = []
        for i in range(args.NState): dipole.append(0)
        for _ in range(len(dipole)):
            dipole[_] = []
            for i in range(args.NState): dipole[_].append(0)
        for istate in range(args.NState):
            for jstate in range(istate + 1,args.NState):
                with open(direcotry/'LISTINGS'/('trncils.FROMdrt1.state' + str(istate+1) + 'TOdrt1.state' + str(jstate+1)), 'r') as f: lines = f.readlines()
                for title_line in range(len(lines)):
                    if 'Transition moment components' in lines[title_line]: break
                temp = lines[title_line + 6].split()
                dipole[istate][jstate] = temp[2:5]
    return geom, energy, gradient, dipole

# Collect geometry, MRCI energy, gradient, transition dipole
def collect() -> None:
    geoms     = []
    energies  = []
    gradients = []
    dipoles   = []
    # Read REFPOINT
    geom, energy, gradient, dipole = read_directory(Path(args.DISPLACEMENT_path/'REFPOINT'))
    geoms    .append(geom    )
    energies .append(energy  )
    gradients.append(gradient)
    dipoles  .append(dipole  )
    # Read displacement points
    for idim in range(intdim):
        for displacement in displacements[idim]:
            geom, energy, gradient, dipole = read_directory(
                Path(args.DISPLACEMENT_path/('CALC.c' + str(idim+1) + '.d' + str(displacement)))
                )
            geoms    .append(geom    )
            energies .append(energy  )
            gradients.append(gradient)
            dipoles  .append(dipole  )
    # Output
    with open(listings/'geom.data','w') as f: # geometry
        for geom in geoms:
            for atom in geom:
                print(atom[:2], atom[10:52], sep='', end='\n', file=f)
    with open(listings/'energy.data','w') as f: # energy
        for energy in energies:
            for state in energy: print(state, end='    ', file=f)
            print(file=f)
    for istate in range(args.NState): # gradient
        with open(listings/('cartgrad-' + str(istate+1) + '.data'), 'w') as f:
            for gradient in gradients:
                for atom in gradient[istate][istate]:
                    print(atom.replace('D', 'e'), end='', file=f)
        for jstate in range(istate + 1, args.NState):
            with open(listings/('cartgrad-' + str(istate+1) + '-' + str(jstate+1) + '.data'), 'w') as f:
                for gradient in gradients:
                    for atom in gradient[istate][jstate]:
                        print(atom.replace('D', 'e'), end='', file=f)
    for istate in range(args.NState): # transition dipole
        for jstate in range(istate+1,args.NState):
            with open(listings/('transdip-'+str(istate+1)+'-'+str(jstate+1)+'.data'),'w') as f:
                for dipole in dipoles:
                    for component in dipole[istate][jstate]: print(component, end='    ', file=f)
                    print(file=f)

# Calculate finite difference Hessian for NState-th state only
def Hessian_single() -> None:
    hessian = numpy.empty((intdim, intdim))
    for displacement in displacements:
        # Reference point is required
        if len(displacement) == 1:
            intgrad_ref = numpy.empty(intdim)
            dir = Path(args.DISPLACEMENT_path/"REFPOINT")
            with open(dir/'GRADIENTS'/('intgrd.drt1.state' + str(args.NState) + '.sp'), 'r') as f: lines = f.readlines()
            for i in range(intdim): intgrad_ref[i] = float(lines[i].replace('D', 'e'))
            break
    # Read internal coordinate gradients and calculate finite difference
    intgrad1 = numpy.empty((intdim))
    intgrad2 = numpy.empty((intdim))
    for idim in range(intdim):
        # This assumes gradient to be antisymmetric
        if len(displacements[idim]) == 1:
            dir = Path(args.DISPLACEMENT_path/('CALC.c' + str(idim+1) + '.d' + str(displacements[idim][0])))
            with open(dir/'GRADIENTS'/('intgrd.drt1.state' + str(args.NState) + '.sp'), 'r') as f: lines = f.readlines()
            for i in range(intdim): intgrad1[i] = float(lines[i].replace('D', 'e'))
            hessian[idim, :] = (intgrad1 - intgrad_ref) / displacements[idim][0]
        elif len(displacements[idim]) == 2:
            dir1 = Path(args.DISPLACEMENT_path/('CALC.c' + str(idim+1) + '.d' + str(displacements[idim][0])))
            dir2 = Path(args.DISPLACEMENT_path/('CALC.c' + str(idim+1) + '.d' + str(displacements[idim][1])))
            with open(dir1/'GRADIENTS'/('intgrd.drt1.state' + str(args.NState) + '.sp'), 'r') as f: lines1 = f.readlines()
            with open(dir2/'GRADIENTS'/('intgrd.drt1.state' + str(args.NState) + '.sp'), 'r') as f: lines2 = f.readlines()
            for i in range(intdim):
                intgrad1[i] = float(lines1[i].replace('D', 'e'))
                intgrad2[i] = float(lines2[i].replace('D', 'e'))
            hessian[idim, :] = (intgrad1 - intgrad2) / (displacements[idim][0] - displacements[idim][1])
        else:
            print("There should be 1 or 2 displacements along internal coordinate", idim, sep=' ')
    # Symmetrize
    for i in range(intdim): 
        for j in range(i+1, intdim):
            hessian[i, j] = (hessian[i, j] + hessian[j, i]) / 2.0
            hessian[j, i] =  hessian[i, j]
    if args.irreducible != None:
        start = 0
        for NCoord in args.irreducible:
            stop = start + NCoord
            hessian[start:stop, :start] = 0.0
            hessian[start:stop, stop: ] = 0.0
            start = stop
    # Output hessian
    # Hessian in Columbus 7 format
    with open(listings/'hessian','w') as f:
        for i in range(intdim):
            for j in range(0,intdim,8):
                jstart=j; jstop=j+8
                if jstop>intdim: jstop=intdim
                for jj in range(jstart,jstop):
                    print('%13.6f' % hessian[i,jj],end='',file=f)
                print(file=f)
    # Diagonal elements in intcfl format
    with open(listings/'hessian_diag','w') as f:
        for j in range(0,intdim,8):
            jstart=j; jstop=j+8
            if jstop>intdim: jstop=intdim
            for jj in range(jstart,jstop):
                print('%10.2E'%hessian[jj,jj],end='',file=f)
            print(file=f)

# Read directory, return (geometry, energy, gradient)
# The return data are original strings
def read_directory_single(direcotry: Path) -> Tuple[List, str, str]:
    # geometry
    with open(direcotry/'geom', 'r') as f: geom = f.readlines()
    # energy
    with open(direcotry/'LISTINGS'/'ciudgsm.sp','r') as f: lines=f.readlines()
    for title_line in range(len(lines)):
        if 'mr-sdci  convergence criteria satisfied' in lines[title_line]: break
    if title_line == len(lines) - 1 :
        print('Warning: mr-sdci did not converge at job ' + str(direcotry))
    else:
        temp = lines[title_line + 2 + args.NState].split()
        energy = temp[len(temp) - 5]
        # gradient
        with open(direcotry/'GRADIENTS'/('cartgrd.drt1.state' + str(args.NState) + '.sp'), 'r') as f:
            gradient = f.readlines()
    return geom, energy, gradient

# Collect geometry, MRCI energy, gradient
def collect_single() -> None:
    geoms     = []
    energies  = []
    gradients = []
    # Read REFPOINT
    geom, energy, gradient = read_directory_single(Path(args.DISPLACEMENT_path/'REFPOINT'))
    geoms    .append(geom    )
    energies .append(energy  )
    gradients.append(gradient)
    # Read displacement points
    for idim in range(intdim):
        for displacement in displacements[idim]:
            geom, energy, gradient = read_directory_single(
                Path(args.DISPLACEMENT_path/('CALC.c' + str(idim+1) + '.d' + str(displacement)))
                )
            geoms    .append(geom    )
            energies .append(energy  )
            gradients.append(gradient)
    # Output
    # geometry
    with open(listings/'geom.data','w') as f:
        for geom in geoms:
            for atom in geom:
                print(atom[:2], atom[10:52], sep='', end='\n', file=f)
    # energy
    with open(listings/'energy.data','w') as f:
        for energy in energies:
            for state in energy: print(state, end='    ', file=f)
            print(file=f)
    # gradient
    with open(listings/('cartgrad-' + str(args.NState) + '.data'), 'w') as f:
        for gradient in gradients:
            for atom in gradient:
                print(atom.replace('D', 'e'), end='', file=f)

if __name__ == "__main__":
    ''' Initialize '''
    args = parse_args() # Command line input
    listings = args.DISPLACEMENT_path/'..'/'LISTINGS' # Get listings
    if not listings.exists(): listings.mkdir()
    with open(args.DISPLACEMENT_path/'displfl','r') as f:
        lines = f.readlines()
        strs = lines[0].split(); intdim = int(strs[0]) # Get intdim
        displacements = [] # Get displacements
        current_coord = -1
        for line in lines[3:]:
            strs = line.split()
            coord = int(strs[0]) - 1
            if coord != current_coord:
                current_coord = coord
                displacements.append([])
            displacements[current_coord].append(float(strs[1]))
    if args.collect: # Get NAtoms
        with open(args.DISPLACEMENT_path/'REFPOINT'/'geom', 'r') as f: NAtoms = len(f.readlines())
    ''' Do the job '''
    if args.single:
        Hessian_single()
        if args.collect: collect_single()
    else:
        Hessian()
        if args.collect: collect()
