"""
Calculate Columbus7 MRCI energy Hessian
This is a finite difference calculation from MRCI analytical gradients
Optionally, additionally collect MRCI energy, gradient, transition dipole
"""

''' Library '''
import argparse
from pathlib import Path
import numpy

''' Global variable '''
NAtoms = 0 # Number of atoms
intdim = 0 # Internal coordinate dimension
displ  = 0 # Displacement of each single point job

def parse_args() -> argparse.Namespace: # Command line input
    parser = argparse.ArgumentParser(__doc__)
    parser.add_argument('DISPLACEMENTPath',type=Path,help='location of DISPLACEMENT directory generated by colinp')
    parser.add_argument('NState',type=int,help='calculate for state 1 to NState')
    parser.add_argument('-c','--collect', action='store_true',help='additionally collect MRCI energy, gradient, transition dipole')
    args = parser.parse_args()
    return args

def Hessian(args: argparse.Namespace): # Calculate finite difference Hessian
    # Read internal coordinate analytical gradients
    intgrad=numpy.empty((intdim,2,args.NState,intdim))
    for i in range(intdim):
        for ii in range(2):
            current=Path(args.DISPLACEMENTPath/('CALC.c'+str(i+1)+'.d'+str(displ[i,ii])))
            for j in range(args.NState):
                with open(current/'GRADIENTS'/('intgrd.drt1.state'+str(j+1)+'.sp'),'r') as f: data=f.readlines()
                for k in range(intdim): intgrad[i,ii,j,k]=float(data[k])
    # Perform finite difference
    hessian=numpy.empty((args.NState,intdim,intdim))
    for istate in range(args.NState):
        for idim in range(intdim):
            hessian[istate,idim,:]=(intgrad[idim,1,istate,:]-intgrad[idim,0,istate,:])/(displ[idim,1]-displ[idim,0])
    for i in range(intdim): # Symmetrize
        for j in range(i+1,intdim):
            hessian[:,i,j]=(hessian[:,i,j]+hessian[:,j,i])/2.0
            hessian[:,j,i]= hessian[:,i,j]
    # Output hessian
    for istate in range(args.NState):
        with open(listings/('hessian'+str(istate+1)),'w') as f:
            for i in range(intdim):
                for j in range(0,intdim,8):
                    jstart=j
                    jstop=j+8
                    if jstop>intdim: jstop=intdim
                    for jj in range(jstart,jstop):
                        print('%13.6f' % hessian[istate,i,jj],end='',file=f)
                    print(file=f)

def collect(args: argparse.Namespace):
    # Allocate memory
    energy=numpy.empty((intdim,2,args.NState))
    cartgrad=numpy.empty((intdim,2,args.NState,args.NState,NAtoms,3))
    intgrad=numpy.empty((intdim,2,args.NState,args.NState,intdim))
    # Read
    for i in range(intdim):
        for ii in range(2):
            current=Path(args.DISPLACEMENTPath/('CALC.c'+str(i+1)+'.d'+str(displ[i,ii])))
            # energy
            with open(current/'LISTINGS'/'ciudgsm.sp','r') as f: lines=f.readlines()
            for j in range(len(lines)):
                if 'mr-sdci  convergence criteria satisfied' in lines[j]: break
            for k in range(args.NState):
                temp=lines[j+2+k+1].split()
                energy[i,ii,k]=float(temp[len(temp)-5].replace('D','e'))
            # gradient
            for istate in range(args.NState):
                with open(current/'GRADIENTS'/('cartgrd.drt1.state'+str(istate+1)+'.sp'),'r') as f: lines=f.readlines()
                for j in range(NAtoms):
                    temp=lines[j].split()
                    for k in range(3): cartgrad[i,ii,istate,istate,j,k]=float(temp[k].replace('D','e'))
                for jstate in range(istate+1,args.NState):
                    with open(current/'GRADIENTS'/('cartgrd.nad.drt1.state'+str(istate+1)+'.drt1.state'+str(jstate+1)+'.sp'),'r') as f: lines=f.readlines()
                    for j in range(NAtoms):
                        temp=lines[j].split()
                        for k in range(3): cartgrad[i,ii,istate,jstate,j,k]=float(temp[k].replace('D','e'))
            # internal coordinate gradient
            for istate in range(args.NState):
                with open(current/'GRADIENTS'/('intgrd.drt1.state'+str(istate+1)+'.sp'),'r') as f: lines=f.readlines()
                for j in range(intdim): intgrad[i,ii,istate,istate,j]=float(lines[j].replace('D','e'))
                for jstate in range(istate+1,args.NState):
                    with open(current/'GRADIENTS'/('intgrd.nad.drt1.state'+str(istate+1)+'.drt1.state'+str(jstate+1)+'.sp'),'r') as f: lines=f.readlines()
                    for j in range(intdim): intgrad[i,ii,istate,jstate,j]=float(lines[j].replace('D','e'))
    # Output
    with open('energy.all','w') as f: # energy
        for i in range(intdim):
            for ii in range(2):
                for j in range(args.NState-1): print(energy[i,ii,j],end=' ',file=f)
                print(energy[i,ii,args.NState-1],file=f)
    for istate in range(args.NState): # gradient
        with open('cartgrd.drt1.state'+str(istate+1)+'.all','w') as f:
            for i in range(intdim):
                for ii in range(2):
                    for j in range(NAtoms): print(cartgrad[i,ii,istate,istate,j,0],cartgrad[i,ii,istate,istate,j,1],cartgrad[i,ii,istate,istate,j,2],sep=' ',file=f)
        for jstate in range(istate+1,args.NState):
            with open('cartgrd.nad.drt1.state'+str(istate+1)+'.drt1.state'+str(jstate+1)+'.all','w') as f:
                for i in range(intdim):
                    for ii in range(2):
                        cartgrad[i,ii,istate,jstate,:,:]=cartgrad[i,ii,istate,jstate,:,:]*(energy[i,ii,jstate]-energy[i,ii,istate])
                        for j in range(NAtoms): print(cartgrad[i,ii,istate,jstate,j,0],cartgrad[i,ii,istate,jstate,j,1],cartgrad[i,ii,istate,jstate,j,2],sep=' ',file=f)
    for istate in range(args.NState): # internal coordinate gradient
        with open('intgrd.drt1.state'+str(istate+1)+'.all','w') as f:
            for i in range(intdim):
                for ii in range(2):
                    for j in range(intdim): print(intgrad[i,ii,istate,istate,j],file=f)
        for jstate in range(istate+1,args.NState):
            with open('intgrd.nad.drt1.state'+str(istate+1)+'.drt1.state'+str(jstate+1)+'.all','w') as f:
                for i in range(intdim):
                    for ii in range(2):
                        intgrad[i,ii,istate,jstate,:]=intgrad[i,ii,istate,jstate,:]*(energy[i,ii,jstate]-energy[i,ii,istate])
                        for j in range(intdim): print(intgrad[i,ii,istate,jstate,j],file=f)

if __name__ == "__main__":
    # Initialize
    args = parse_args()
    listings=args.DISPLACEMENTPath/'..'/'LISTINGS'
    if not listings.exists(): listings.mkdir()
    with open(args.DISPLACEMENTPath/'displfl','r') as f:
        data=f.readlines()
        temp=data[0].split(); intdim=int(temp[0])
        displ=numpy.empty((intdim,2))
        for i in range(intdim):
            temp=data[3+2*i].split()  ; displ[i,0]=float(temp[1])
            temp=data[3+2*i+1].split(); displ[i,1]=float(temp[1])
    if args.collect: # Get NAtoms
        with open(args.DISPLACEMENTPath/('CALC.c1.d'+str(displ[0,0]))/'geom','r') as f:
            NAtoms=len(f.readlines())
    # Do the job
    Hessian(args)
    if args.collect: collect(args)
