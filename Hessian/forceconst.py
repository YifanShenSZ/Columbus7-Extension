"""
Calculate Columbus7 MRCI energy internal coordinate Hessian
Output to DISPLACEMENT/../LISTINGS
This is a finite difference calculation from gradients
Note that Columbus internal coordinate routines use weird unit:
    energy in 10^-18 J, length in A (to be continued)
Optionally, additionally collect geometry, MRCI energy, gradient, transition dipole
Please note that interstate coupling replaces nonadiabatic coupling
"""

''' Library '''
import argparse
from pathlib import Path
import numpy

''' Global variable '''
listings = 0 # Output path
intdim   = 0 # Internal coordinate dimension
displ    = 0 # Displacement of each single point job
NAtoms   = 0 # Number of atoms

''' Routine '''
def parse_args() -> argparse.Namespace: # Command line input
    parser = argparse.ArgumentParser(__doc__)
    parser.add_argument('DISPLACEMENTPath', type=Path, help='location of DISPLACEMENT directory generated by colinp')
    parser.add_argument('NState', type=int, help='calculate for state 1 to NState')
    parser.add_argument('-c', '--collect', action='store_true', help='additionally collect geometry, MRCI energy, gradient, transition dipole')
    args = parser.parse_args()
    return args

def Hessian(args: argparse.Namespace): # Calculate finite difference Hessian
    # Read internal coordinate gradients
    intgrad=numpy.empty((intdim,2,args.NState,intdim))
    for i in range(intdim):
        for ii in range(2):
            current=Path(args.DISPLACEMENTPath/('CALC.c'+str(i+1)+'.d'+str(displ[i,ii])))
            for j in range(args.NState):
                with open(current/'GRADIENTS'/('intgrd.drt1.state'+str(j+1)+'.sp'),'r') as f: lines=f.readlines()
                for k in range(intdim): intgrad[i,ii,j,k]=float(lines[k].replace('D','e'))
    # Perform finite difference
    hessian=numpy.empty((args.NState,intdim,intdim))
    for istate in range(args.NState):
        for idim in range(intdim):
            hessian[istate,idim,:]=(intgrad[idim,1,istate,:]-intgrad[idim,0,istate,:])/(displ[idim,1]-displ[idim,0])
    for i in range(intdim): # Symmetrize
        for j in range(i+1,intdim):
            hessian[:,i,j]=(hessian[:,i,j]+hessian[:,j,i])/2.0
            hessian[:,j,i]= hessian[:,i,j]
    # Output hessian
    for istate in range(args.NState):
        # Hessian in Columbus 7 format
        with open(listings/('hessian'+str(istate+1)),'w') as f:
            for i in range(intdim):
                for j in range(0,intdim,8):
                    jstart=j; jstop=j+8
                    if jstop>intdim: jstop=intdim
                    for jj in range(jstart,jstop):
                        print('%13.6f' % hessian[istate,i,jj],end='',file=f)
                    print(file=f)
        # Diagonal elements in intcfl format
        with open(listings/('hessian_diag_'+str(istate+1)),'w') as f:
            for j in range(0,intdim,8):
                jstart=j; jstop=j+8
                if jstop>intdim: jstop=intdim
                for jj in range(jstart,jstop):
                    print('%10.2E'%hessian[istate,jj,jj],end='',file=f)
                print(file=f)

def collect(args: argparse.Namespace):
    # Allocate memory
    geom=[]
    ref_energy  =numpy.empty( args.NState)
    ref_cartgrad=numpy.empty((args.NState,args.NState,NAtoms,3))
    ref_dipole  =numpy.empty((args.NState,args.NState,3))
    energy  =numpy.empty((intdim,2,args.NState))
    cartgrad=numpy.empty((intdim,2,args.NState,args.NState,NAtoms,3))
    dipole  =numpy.empty((intdim,2,args.NState,args.NState,3))
    # Read
    ## REFPOINT
    current=Path(args.DISPLACEMENTPath/'REFPOINT')
    ### geometry
    with open(current/'geom','r') as f: geom.append(f.readlines())
    ### energy
    with open(current/'LISTINGS'/'ciudgsm.sp','r') as f: lines=f.readlines()
    for j in range(len(lines)):
        if 'mr-sdci  convergence criteria satisfied' in lines[j]: break
    if j == len(lines) - 1 :
        print('Warning: mr-sdci did not converge at job '+str(current))
    else:
        for k in range(args.NState):
            temp=lines[j+2+k+1].split()
            ref_energy[k]=float(temp[len(temp)-5].replace('D','e'))
        # gradient
        for istate in range(args.NState):
            with open(current/'GRADIENTS'/('cartgrd.drt1.state'+str(istate+1)+'.sp'),'r') as f: lines=f.readlines()
            for j in range(NAtoms):
                temp=lines[j].split()
                for k in range(3): ref_cartgrad[istate,istate,j,k]=float(temp[k].replace('D','e'))
            for jstate in range(istate+1,args.NState):
                with open(current/'GRADIENTS'/('cartgrd.nad.drt1.state'+str(istate+1)+'.drt1.state'+str(jstate+1)+'.sp'),'r') as f: lines=f.readlines()
                for j in range(NAtoms):
                    temp=lines[j].split()
                    for k in range(3): ref_cartgrad[istate,jstate,j,k]=float(temp[k].replace('D','e'))
        # transition dipole
        for istate in range(args.NState):
            for jstate in range(istate+1,args.NState):
                with open(current/'LISTINGS'/('trncils.FROMdrt1.state'+str(istate+1)+'TOdrt1.state'+str(jstate+1)),'r') as f: lines=f.readlines()
                for j in range(len(lines)):
                    if 'Transition moment components' in lines[j]: break
                temp=lines[j+6].split()
                ref_dipole[istate,jstate,0]=float(temp[2].replace('D','e'))
                ref_dipole[istate,jstate,1]=float(temp[3].replace('D','e'))
                ref_dipole[istate,jstate,2]=float(temp[4].replace('D','e'))
    ## Displacement points
    for i in range(intdim):
        for ii in range(2):
            current=Path(args.DISPLACEMENTPath/('CALC.c'+str(i+1)+'.d'+str(displ[i,ii])))
            # geometry
            with open(current/'geom','r') as f: geom.append(f.readlines())
            # energy
            with open(current/'LISTINGS'/'ciudgsm.sp','r') as f: lines=f.readlines()
            for j in range(len(lines)):
                if 'mr-sdci  convergence criteria satisfied' in lines[j]: break
            if j == len(lines) - 1 :
                print('Warning: mr-sdci did not converge at job '+str(current))
            else:
                for k in range(args.NState):
                    temp=lines[j+2+k+1].split()
                    energy[i,ii,k]=float(temp[len(temp)-5].replace('D','e'))
                # gradient
                for istate in range(args.NState):
                    with open(current/'GRADIENTS'/('cartgrd.drt1.state'+str(istate+1)+'.sp'),'r') as f: lines=f.readlines()
                    for j in range(NAtoms):
                        temp=lines[j].split()
                        for k in range(3): cartgrad[i,ii,istate,istate,j,k]=float(temp[k].replace('D','e'))
                    for jstate in range(istate+1,args.NState):
                        with open(current/'GRADIENTS'/('cartgrd.nad.drt1.state'+str(istate+1)+'.drt1.state'+str(jstate+1)+'.sp'),'r') as f: lines=f.readlines()
                        for j in range(NAtoms):
                            temp=lines[j].split()
                            for k in range(3): cartgrad[i,ii,istate,jstate,j,k]=float(temp[k].replace('D','e'))
                # transition dipole
                for istate in range(args.NState):
                    for jstate in range(istate+1,args.NState):
                        with open(current/'LISTINGS'/('trncils.FROMdrt1.state'+str(istate+1)+'TOdrt1.state'+str(jstate+1)),'r') as f: lines=f.readlines()
                        for j in range(len(lines)):
                            if 'Transition moment components' in lines[j]: break
                        temp=lines[j+6].split()
                        dipole[i,ii,istate,jstate,0]=float(temp[2].replace('D','e'))
                        dipole[i,ii,istate,jstate,1]=float(temp[3].replace('D','e'))
                        dipole[i,ii,istate,jstate,2]=float(temp[4].replace('D','e'))
    # Output
    with open(listings/'geom.data','w') as f: # geometry
        for i in range(len(geom)):
            for j in range(len(geom[i])):
                print(geom[i][j][:2],geom[i][j][10:52],sep='',end='\n',file=f)
    with open(listings/'energy.data','w') as f: # energy
        # REFPOINT
        for j in range(args.NState-1): print('%25.15E'%ref_energy[j],end='',file=f)
        print('%25.15E'%ref_energy[args.NState-1],file=f)
        # Displacement points
        for i in range(intdim):
            for ii in range(2):
                for j in range(args.NState-1): print('%25.15E'%energy[i,ii,j],end=' ',file=f)
                print('%25.15E'%energy[i,ii,args.NState-1],file=f)
    for istate in range(args.NState): # gradient
        with open(listings/('cartgrad-'+str(istate+1)+'.data'),'w') as f:
            # REFPOINT
            for j in range(NAtoms): print('%25.15E%25.15E%25.15E'%(ref_cartgrad[istate,istate,j,0],ref_cartgrad[istate,istate,j,1],ref_cartgrad[istate,istate,j,2]),file=f)
            # Displacement points
            for i in range(intdim):
                for ii in range(2):
                    for j in range(NAtoms): print('%25.15E%25.15E%25.15E'%(cartgrad[i,ii,istate,istate,j,0],cartgrad[i,ii,istate,istate,j,1],cartgrad[i,ii,istate,istate,j,2]),file=f)
        for jstate in range(istate+1,args.NState):
            with open(listings/('cartgrad-'+str(istate+1)+'-'+str(jstate+1)+'.data'),'w') as f:
                # REFPOINT
                ref_cartgrad[istate,jstate,:,:]=ref_cartgrad[istate,jstate,:,:]*(ref_energy[jstate]-ref_energy[istate])
                for j in range(NAtoms): print('%25.15E%25.15E%25.15E'%(ref_cartgrad[istate,jstate,j,0],ref_cartgrad[istate,jstate,j,1],ref_cartgrad[istate,jstate,j,2]),file=f)
                # Displacement points
                for i in range(intdim):
                    for ii in range(2):
                        cartgrad[i,ii,istate,jstate,:,:]=cartgrad[i,ii,istate,jstate,:,:]*(energy[i,ii,jstate]-energy[i,ii,istate])
                        for j in range(NAtoms): print('%25.15E%25.15E%25.15E'%(cartgrad[i,ii,istate,jstate,j,0],cartgrad[i,ii,istate,jstate,j,1],cartgrad[i,ii,istate,jstate,j,2]),file=f)
    for istate in range(args.NState): # transition dipole
        for jstate in range(istate+1,args.NState):
            with open(listings/('transdip-'+str(istate+1)+'-'+str(jstate+1)+'.data'),'w') as f:
                # REFPOINT
                print('%25.15E%25.15E%25.15E'%(ref_dipole[istate,jstate,0],ref_dipole[istate,jstate,1],ref_dipole[istate,jstate,2]),file=f)
                # Displacement points
                for i in range(intdim):
                    for ii in range(2):
                        print('%25.15E%25.15E%25.15E'%(dipole[i,ii,istate,jstate,0],dipole[i,ii,istate,jstate,1],dipole[i,ii,istate,jstate,2]),file=f)

if __name__ == "__main__":
    ''' Initialize '''
    args = parse_args() # Command line input
    listings=args.DISPLACEMENTPath/'..'/'LISTINGS' # Get listings
    if not listings.exists(): listings.mkdir()
    with open(args.DISPLACEMENTPath/'displfl','r') as f:
        lines=f.readlines()
        temp=lines[0].split(); intdim=int(temp[0]) # Get intdim
        displ=numpy.empty((intdim,2)) # Get displ
        for i in range(intdim):
            temp=lines[3+2*i].split()  ; displ[i,0]=float(temp[1])
            temp=lines[3+2*i+1].split(); displ[i,1]=float(temp[1])
    ''' Do the job ''' 
    Hessian(args)
    if args.collect:
        with open(args.DISPLACEMENTPath/'REFPOINT'/'geom','r') as f: NAtoms=len(f.readlines()) # Get NAtoms
        collect(args)